### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type File {
  createdAt: DateTime!
  extension: String!
  fullUrl: String!
  height: Int
  id: ID!
  isUploaded: Boolean
  name: String!
  size: String
  squareUrl: String!
  updatedAt: DateTime!
  uploadGroup: UploadGroup!
  width: Int
}

input FileCreateInput {
  createdAt: DateTime
  extension: String!
  hasStartedUploading: Boolean
  height: Int
  id: ID
  isFailed: Boolean
  isUploaded: Boolean
  item: ItemCreateOneWithoutItemInput!
  name: String!
  size: String
  updatedAt: DateTime
  uploadGroup: UploadGroupCreateOneWithoutUploadGroupInput!
  user: UserCreateOneWithoutUserInput!
  width: Int
}

input FileCreateManyWithoutFilesInput {
  connect: [FileWhereUniqueInput!]
  create: [FileCreateWithoutUploadGroupInput!]
}

input FileCreateOneWithoutFileInput {
  connect: FileWhereUniqueInput
  create: FileCreateWithoutItemInput
}

input FileCreateWithoutItemInput {
  createdAt: DateTime
  extension: String!
  hasStartedUploading: Boolean
  height: Int
  id: ID
  isFailed: Boolean
  isUploaded: Boolean
  name: String!
  size: String
  updatedAt: DateTime
  uploadGroup: UploadGroupCreateOneWithoutUploadGroupInput!
  user: UserCreateOneWithoutUserInput!
  width: Int
}

input FileCreateWithoutUploadGroupInput {
  createdAt: DateTime
  extension: String!
  hasStartedUploading: Boolean
  height: Int
  id: ID
  isFailed: Boolean
  isUploaded: Boolean
  item: ItemCreateOneWithoutItemInput!
  name: String!
  size: String
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
  width: Int
}

input FileFilter {
  every: FileWhereInput
  none: FileWhereInput
  some: FileWhereInput
}

input FileOrderByInput {
  createdAt: OrderByArg
  extension: OrderByArg
  hasStartedUploading: OrderByArg
  height: OrderByArg
  id: OrderByArg
  isFailed: OrderByArg
  isUploaded: OrderByArg
  name: OrderByArg
  size: OrderByArg
  updatedAt: OrderByArg
  width: OrderByArg
}

input FileWhereInput {
  AND: [FileWhereInput!]
  createdAt: DateTimeFilter
  extension: StringFilter
  hasStartedUploading: NullableBooleanFilter
  height: NullableIntFilter
  id: StringFilter
  isFailed: NullableBooleanFilter
  isUploaded: NullableBooleanFilter
  item: ItemWhereInput
  name: StringFilter
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  size: NullableStringFilter
  updatedAt: DateTimeFilter
  uploadGroup: UploadGroupWhereInput
  user: UserWhereInput
  width: NullableIntFilter
}

input FileWhereUniqueInput {
  id: ID
}

input GoogleAccountCreateManyWithoutGoogleAccountsInput {
  connect: [GoogleAccountWhereUniqueInput!]
  create: [GoogleAccountCreateWithoutUserInput!]
}

input GoogleAccountCreateWithoutUserInput {
  accountId: String
  createdAt: DateTime
  email: String
  firstName: String
  id: ID
  lastName: String
  picture: String
  refreshToken: String
  updatedAt: DateTime
}

input GoogleAccountFilter {
  every: GoogleAccountWhereInput
  none: GoogleAccountWhereInput
  some: GoogleAccountWhereInput
}

input GoogleAccountWhereInput {
  accountId: NullableStringFilter
  AND: [GoogleAccountWhereInput!]
  createdAt: DateTimeFilter
  email: NullableStringFilter
  firstName: NullableStringFilter
  id: StringFilter
  lastName: NullableStringFilter
  NOT: [GoogleAccountWhereInput!]
  OR: [GoogleAccountWhereInput!]
  picture: NullableStringFilter
  refreshToken: NullableStringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input GoogleAccountWhereUniqueInput {
  accountId: String
  id: ID
}

type InProgressUpload {
  signedUrls: [String!]!
  uploadGroup: UploadGroup
}

type Item {
  createdAt: DateTime!
  file: File
  id: ID!
  labels(after: ID, before: ID, first: Int, last: Int, skip: Int): [Label!]!
  link: Link
  note: Note
  type: String!
  updatedAt: DateTime!
}

input ItemCreateManyWithoutItemsInput {
  connect: [ItemWhereUniqueInput!]
  create: [ItemCreateWithoutUserInput!]
}

input ItemCreateOneWithoutItemInput {
  connect: ItemWhereUniqueInput
  create: ItemCreateWithoutLinkInput
}

input ItemCreateWithoutLinkInput {
  createdAt: DateTime
  file: FileCreateOneWithoutFileInput
  id: ID
  labels: LabelCreateManyWithoutLabelsInput
  note: NoteCreateOneWithoutNoteInput
  type: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput
}

input ItemCreateWithoutUserInput {
  createdAt: DateTime
  file: FileCreateOneWithoutFileInput
  id: ID
  labels: LabelCreateManyWithoutLabelsInput
  link: LinkCreateOneWithoutLinkInput
  note: NoteCreateOneWithoutNoteInput
  type: String!
  updatedAt: DateTime
}

input ItemFilter {
  every: ItemWhereInput
  none: ItemWhereInput
  some: ItemWhereInput
}

input ItemOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  type: OrderByArg
  updatedAt: OrderByArg
}

enum ItemType {
  file
  link
  note
}

input ItemWhereInput {
  AND: [ItemWhereInput!]
  createdAt: DateTimeFilter
  file: FileWhereInput
  id: StringFilter
  labels: LabelFilter
  link: LinkWhereInput
  NOT: [ItemWhereInput!]
  note: NoteWhereInput
  OR: [ItemWhereInput!]
  type: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input ItemWhereUniqueInput {
  id: ID
}

type JWT {
  token: String!
}

type Label {
  createdAt: DateTime!
  id: ID!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
  name: String!
  updatedAt: DateTime!
}

input LabelCreateManyWithoutLabelsInput {
  connect: [LabelWhereUniqueInput!]
  create: [LabelCreateWithoutUserInput!]
}

input LabelCreateWithoutUserInput {
  createdAt: DateTime
  id: ID
  items: ItemCreateManyWithoutItemsInput
  name: String!
  updatedAt: DateTime
}

input LabelFilter {
  every: LabelWhereInput
  none: LabelWhereInput
  some: LabelWhereInput
}

input LabelWhereInput {
  AND: [LabelWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  items: ItemFilter
  name: StringFilter
  NOT: [LabelWhereInput!]
  OR: [LabelWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input LabelWhereUniqueInput {
  id: ID
}

type Link {
  createdAt: DateTime!
  description: String
  favicon: String
  href: String!
  id: ID!
  image: String
  item: Item!
  notes: String!
  title: String
  updatedAt: DateTime!
}

input LinkCreateManyWithoutLinksInput {
  connect: [LinkWhereUniqueInput!]
  create: [LinkCreateWithoutUserInput!]
}

input LinkCreateOneWithoutLinkInput {
  connect: LinkWhereUniqueInput
  create: LinkCreateWithoutItemInput
}

input LinkCreateWithoutItemInput {
  createdAt: DateTime
  description: String
  favicon: String
  href: String!
  id: ID
  image: String
  notes: String!
  title: String
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input LinkCreateWithoutUserInput {
  createdAt: DateTime
  description: String
  favicon: String
  href: String!
  id: ID
  image: String
  item: ItemCreateOneWithoutItemInput!
  notes: String!
  title: String
  updatedAt: DateTime
}

input LinkFilter {
  every: LinkWhereInput
  none: LinkWhereInput
  some: LinkWhereInput
}

input LinkWhereInput {
  AND: [LinkWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  favicon: NullableStringFilter
  href: StringFilter
  id: StringFilter
  image: NullableStringFilter
  item: ItemWhereInput
  NOT: [LinkWhereInput!]
  notes: StringFilter
  OR: [LinkWhereInput!]
  title: NullableStringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input LinkWhereUniqueInput {
  id: ID
}

type Mutation {
  connectLabelToItem(itemId: String!, name: String!): Item!
  createLabel(itemId: String, name: String!): User!
  createLink(href: String!): Link!
  createNote(raw: String!, text: String!): Note!
  createOneFile(data: FileCreateInput!): File!
  createOneUser(data: UserCreateInput!): User!
  deleteItem(itemId: String!): Item!
  deleteLabel(labelId: String!): User!
  deleteOneFile(where: FileWhereUniqueInput!): File
  disconnectLabelFromItem(itemId: String!, labelId: String!): Item!
  generateSignedUrls(signedURLArgs: [SignedURLArgs!]): InProgressUpload!
  googleSignIn(code: String!): JWT!
  processFiles(uploadGroupId: String): [File!]!
  updateNote(noteId: String!, raw: String!, text: String!): Note!
}

type Note {
  createdAt: DateTime!
  id: ID!
  item: Item!
  raw: String!
  text: String!
  updatedAt: DateTime!
}

input NoteCreateManyWithoutNotesInput {
  connect: [NoteWhereUniqueInput!]
  create: [NoteCreateWithoutUserInput!]
}

input NoteCreateOneWithoutNoteInput {
  connect: NoteWhereUniqueInput
  create: NoteCreateWithoutItemInput
}

input NoteCreateWithoutItemInput {
  createdAt: DateTime
  id: ID
  raw: String!
  text: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input NoteCreateWithoutUserInput {
  createdAt: DateTime
  id: ID
  item: ItemCreateOneWithoutItemInput!
  raw: String!
  text: String!
  updatedAt: DateTime
}

input NoteFilter {
  every: NoteWhereInput
  none: NoteWhereInput
  some: NoteWhereInput
}

input NoteWhereInput {
  AND: [NoteWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  item: ItemWhereInput
  NOT: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  raw: StringFilter
  text: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input NoteWhereUniqueInput {
  id: ID
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  _files(after: ID, before: ID, first: Int, last: Int, orderBy: FileOrderByInput, skip: Int, where: FileWhereInput): [File!]!
  _items(after: ID, before: ID, first: Int, last: Int, orderBy: ItemOrderByInput, skip: Int, where: ItemWhereInput): [Item!]!
  _uploadgroups(after: ID, before: ID, first: Int, last: Int, orderBy: UploadGroupOrderByInput, skip: Int, where: UploadGroupWhereInput): [UploadGroup!]!
  file(where: FileWhereUniqueInput!): File
  googleURL: String!
  item(id: String!): Item!
  items(after: String, before: String, first: Int, last: Int, orderBy: ItemOrderByInput, search: String, skip: Int, type: ItemType, where: ItemWhereInput): [Item!]!
  me: User
  mostRecentItem(type: String): Item
  test: String!
  uploadGroups(after: String, before: String, first: Int, last: Int, orderBy: UploadGroupOrderByInput, skip: Int, where: UploadGroupWhereInput): [UploadGroup!]!
  users(after: ID, before: ID, first: Int, last: Int, skip: Int): [User!]!
}

input SignedURLArgs {
  key: String!
  name: String!
  type: String!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadGroup {
  createdAt: DateTime!
  files(after: ID, before: ID, first: Int, last: Int, skip: Int): [File!]!
  id: ID!
  isComplete: Boolean
  updatedAt: DateTime!
}

input UploadGroupCreateManyWithoutUploadGroupsInput {
  connect: [UploadGroupWhereUniqueInput!]
  create: [UploadGroupCreateWithoutUserInput!]
}

input UploadGroupCreateOneWithoutUploadGroupInput {
  connect: UploadGroupWhereUniqueInput
  create: UploadGroupCreateWithoutFilesInput
}

input UploadGroupCreateWithoutFilesInput {
  createdAt: DateTime
  id: ID
  isComplete: Boolean
  isFailed: Boolean
  updatedAt: DateTime
  user: UserCreateOneWithoutUserInput!
}

input UploadGroupCreateWithoutUserInput {
  createdAt: DateTime
  files: FileCreateManyWithoutFilesInput
  id: ID
  isComplete: Boolean
  isFailed: Boolean
  updatedAt: DateTime
}

input UploadGroupFilter {
  every: UploadGroupWhereInput
  none: UploadGroupWhereInput
  some: UploadGroupWhereInput
}

input UploadGroupOrderByInput {
  createdAt: OrderByArg
  id: OrderByArg
  isComplete: OrderByArg
  isFailed: OrderByArg
  updatedAt: OrderByArg
}

input UploadGroupWhereInput {
  AND: [UploadGroupWhereInput!]
  createdAt: DateTimeFilter
  files: FileFilter
  id: StringFilter
  isComplete: NullableBooleanFilter
  isFailed: NullableBooleanFilter
  NOT: [UploadGroupWhereInput!]
  OR: [UploadGroupWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input UploadGroupWhereUniqueInput {
  id: ID
}

type User {
  email: String!
  files(after: ID, before: ID, first: Int, last: Int, skip: Int): [File!]!
  firstName: String
  fullName: String!
  id: ID!
  items(after: ID, before: ID, first: Int, last: Int, skip: Int): [Item!]!
  labels(after: ID, before: ID, first: Int, last: Int, skip: Int): [Label!]!
  lastName: String
}

input UserCreateInput {
  email: String!
  files: FileCreateManyWithoutFilesInput
  firstName: String
  googleAccounts: GoogleAccountCreateManyWithoutGoogleAccountsInput
  id: ID
  items: ItemCreateManyWithoutItemsInput
  labels: LabelCreateManyWithoutLabelsInput
  lastName: String
  links: LinkCreateManyWithoutLinksInput
  notes: NoteCreateManyWithoutNotesInput
  uploadGroups: UploadGroupCreateManyWithoutUploadGroupsInput
}

input UserCreateOneWithoutUserInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutFilesInput
}

input UserCreateWithoutFilesInput {
  email: String!
  firstName: String
  googleAccounts: GoogleAccountCreateManyWithoutGoogleAccountsInput
  id: ID
  items: ItemCreateManyWithoutItemsInput
  labels: LabelCreateManyWithoutLabelsInput
  lastName: String
  links: LinkCreateManyWithoutLinksInput
  notes: NoteCreateManyWithoutNotesInput
  uploadGroups: UploadGroupCreateManyWithoutUploadGroupsInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  files: FileFilter
  firstName: NullableStringFilter
  googleAccounts: GoogleAccountFilter
  id: StringFilter
  items: ItemFilter
  labels: LabelFilter
  lastName: NullableStringFilter
  links: LinkFilter
  NOT: [UserWhereInput!]
  notes: NoteFilter
  OR: [UserWhereInput!]
  uploadGroups: UploadGroupFilter
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
